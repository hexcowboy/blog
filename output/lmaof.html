<!doctype html>
<html>
  <head>
    <!-- Browser meta for viewability -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="canonical" href="">

    <!-- Site meta tags for SEO -->
    <title>hexcowboy - LMAOf</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Facebook Open Graph tags -->
    <meta property="og:title" content="" />
    <meta property="og:Section" content="" />
    <meta property="og:url" content="" />
    <meta property="og:image" content="" />
    <meta property="og:site_name" content="" />
    <meta property="fb:admins" content="" />
    <meta property="og:description" content="" />

    <!-- Twitter tags -->
    <meta property="twitter:account_id" content="" />
    <meta name="twitter:card" content="">
    <meta name="twitter:site" content="">
    <meta name="twitter:creator" content="">
    <meta name="twitter:title" content="">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="">
    <meta name="twitter:domain" content="">

    <!-- Assets -->
    <link rel="shortcut icon" href="">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="stylesheet" href="/theme/css/main.css">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel="stylesheet">

    <!-- Atom and RSS feeds -->

  </head>

  <body>
    <header>
      <div id="title">
        <h1 class="title"><a href="/">hexcowboy</a></h1>
      </div>
      <nav id="socials">
        <a href="https://discordapp.com/users/418557177825853443" target="_blank">
          <i class="fab fa-discord"></i>
        </a>
        <a href="https://github.com/hexcowboy" target="_blank">
          <i class="fab fa-github"></i>
        </a>
        <a href="https://twitter.com/hexcowboy" target="_blank">
          <i class="fab fa-twitter"></i>
        </a>
      </nav>
    </header>

    <main>
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="/lmaof.html" rel="bookmark"
         title="Permalink to LMAOf">LMAOf</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2010-12-03T10:20:00-06:00">
      Fri 03 December 2010
    </time>
    <address class="vcard author">
      By           <a class="url fn" href="/author/hexcowboy.html">hexcowboy</a>
    </address>
    <div class="category">
        Category: <a href="/category/review.html">Review</a>
    </div>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>Articles and pages
Pelican considers “articles” to be chronological content, such as posts on a blog, and thus associated with a date.</p>
<p>The idea behind “pages” is that they are usually not temporal in nature and are used for content that does not change very often (e.g., “About” or “Contact” pages).</p>
<p>You can find sample content in the repository at samples/content/.</p>
<p>File metadata
Pelican tries to be smart enough to get the information it needs from the file system (for instance, about the category of your articles), but some information you need to provide in the form of metadata inside your files.</p>
<p>If you are writing your content in reStructuredText format, you can provide this metadata in text files via the following syntax (give your file the .rst extension):</p>
<p>My super title</p>
<h6></h6>
<p>:date: 2010-10-03 10:20
:modified: 2010-10-04 18:40
:tags: thats, awesome
:category: yeah
:slug: my-super-post
:authors: Alexis Metaireau, Conan Doyle
:summary: Short version for index and feeds
Author and tag lists may be semicolon-separated instead, which allows you to write authors and tags containing commas:</p>
<p>:tags: pelican, publishing tool; pelican, bird
:authors: Metaireau, Alexis; Doyle, Conan
Pelican implements an extension to reStructuredText to enable support for the abbr HTML tag. To use it, write something like this in your post:</p>
<p>This will be turned into :abbr:<code>HTML (HyperText Markup Language)</code>.
You can also use Markdown syntax (with a file ending in .md, .markdown, .mkd, or .mdown). Markdown generation requires that you first explicitly install the Python-Markdown package, which can be done via pip install Markdown.</p>
<p>Pelican also supports Markdown Extensions, which might have to be installed separately if they are not included in the default Markdown package and can be configured and loaded via the MARKDOWN setting.</p>
<p>Metadata syntax for Markdown posts should follow this pattern:</p>
<p>Title: My super title
Date: 2010-12-03 10:20
Modified: 2010-12-05 19:30
Category: Python
Tags: pelican, publishing
Slug: my-super-post
Authors: Alexis Metaireau, Conan Doyle
Summary: Short version for index and feeds</p>
<p>This is the content of my super blog post.
You can also have your own metadata keys (so long as they don’t conflict with reserved metadata keywords) for use in your templates. The following table contains a list of reserved metadata keywords:</p>
<p>Metadata    Description
title   Title of the article or page
date    Publication date (e.g., YYYY-MM-DD HH:SS)
modified    Modification date (e.g., YYYY-MM-DD HH:SS)
tags    Content tags, separated by commas
keywords    Content keywords, separated by commas (HTML content only)
category    Content category (one only — not multiple)
slug    Identifier used in URLs and translations
author  Content author, when there is only one
authors Content authors, when there are multiple
summary Brief description of content for index pages
lang    Content language ID (en, fr, etc.)
translation If content is a translation of another (true or false)
status  Content status: draft, hidden, or published
template    Name of template to use to generate content (without extension)
save_as Save content to this relative file path
url URL to use for this article/page
Readers for additional formats (such as AsciiDoc) are available via plugins. Refer to pelican-plugins repository for those.</p>
<p>Pelican can also process HTML files ending in .html and .htm. Pelican interprets the HTML in a very straightforward manner, reading metadata from meta tags, the title from the title tag, and the body out from the body tag:</p>
<p><html>
    <head>
        <title>My super title</title>
        <meta name="tags" content="thats, awesome" />
        <meta name="date" content="2012-07-09 22:28" />
        <meta name="modified" content="2012-07-10 20:14" />
        <meta name="category" content="yeah" />
        <meta name="authors" content="Alexis Métaireau, Conan Doyle" />
        <meta name="summary" content="Short version for index and feeds" />
    </head>
    <body>
        This is the content of my super blog post.
    </body>
</html>
With HTML, there is one simple exception to the standard metadata: tags can be specified either via the tags metadata, as is standard in Pelican, or via the keywords metadata, as is standard in HTML. The two can be used interchangeably.</p>
<p>Note that, aside from the title, none of this content metadata is mandatory: if the date is not specified and DEFAULT_DATE is set to 'fs', Pelican will rely on the file’s “mtime” timestamp, and the category can be determined by the directory in which the file resides. For example, a file located at python/foobar/myfoobar.rst will have a category of foobar. If you would like to organize your files in other ways where the name of the subfolder would not be a good category name, you can set the setting USE_FOLDER_AS_CATEGORY to False. When parsing dates given in the page metadata, Pelican supports the W3C’s suggested subset ISO 8601.</p>
<p>So the title is the only required metadata. If that bothers you, worry not. Instead of manually specifying a title in your metadata each time, you can use the source content file name as the title. For example, a Markdown source file named Publishing via Pelican.md would automatically be assigned a title of Publishing via Pelican. If you would prefer this behavior, add the following line to your settings file:</p>
<p>FILENAME_METADATA = '(?P<title>.*)'
Note</p>
<p>When experimenting with different settings (especially the metadata ones) caching may interfere and the changes may not be visible. In such cases disable caching with LOAD_CONTENT_CACHE = False or use the --ignore-cache command-line switch.</p>
<p>modified should be last time you updated the article, and defaults to date if not specified. Besides you can show modified in the templates, feed entries in feed readers will be updated automatically when you set modified to the current date after you modified your article.</p>
<p>authors is a comma-separated list of article authors. If there’s only one author you can use author field.</p>
<p>If you do not explicitly specify summary metadata for a given post, the SUMMARY_MAX_LENGTH setting can be used to specify how many words from the beginning of an article are used as the summary.</p>
<p>You can also extract any metadata from the filename through a regular expression to be set in the FILENAME_METADATA setting. All named groups that are matched will be set in the metadata object. The default value for the FILENAME_METADATA setting will only extract the date from the filename. For example, if you would like to extract both the date and the slug, you could set something like: '(?P<date>\d{4}-\d{2}-\d{2})_(?P<slug>.*)'</p>
<p>Please note that the metadata available inside your files takes precedence over the metadata extracted from the filename.</p>
<p>Pages
If you create a folder named pages inside the content folder, all the files in it will be used to generate static pages, such as About or Contact pages. (See example filesystem layout below.)</p>
<p>You can use the DISPLAY_PAGES_ON_MENU setting to control whether all those pages are displayed in the primary navigation menu. (Default is True.)</p>
<p>If you want to exclude any pages from being linked to or listed in the menu then add a status: hidden attribute to its metadata. This is useful for things like making error pages that fit the generated theme of your site.</p>
<p>Static content
Static files are files other than articles and pages that are copied to the output folder as-is, without processing. You can control which static files are copied over with the STATIC_PATHS setting of the project’s pelicanconf.py file. Pelican’s default configuration includes the images directory for this, but others must be added manually. In addition, static files that are explicitly linked to are included (see below).</p>
<p>Mixed content in the same directory
Starting with Pelican 3.5, static files can safely share a source directory with page source files, without exposing the page sources in the generated site. Any such directory must be added to both STATIC_PATHS and PAGE_PATHS (or STATIC_PATHS and ARTICLE_PATHS). Pelican will identify and process the page source files normally, and copy the remaining files as if they lived in a separate directory reserved for static files.</p>
<p>Note: Placing static and content source files together in the same source directory does not guarantee that they will end up in the same place in the generated site. The easiest way to do this is by using the {attach} link syntax (described below). Alternatively, the STATIC_SAVE_AS, PAGE_SAVE_AS, and ARTICLE_SAVE_AS settings (and the corresponding *_URL settings) can be configured to place files of different types together, just as they could in earlier versions of Pelican.</p>
<p>Linking to internal content
From Pelican 3.1 onwards, it is now possible to specify intra-site links to files in the source content hierarchy instead of files in the generated hierarchy. This makes it easier to link from the current post to other content that may be sitting alongside that post (instead of having to determine where the other content will be placed after site generation).</p>
<p>To link to internal content (files in the content directory), use the following syntax for the link target: {filename}path/to/file Note: forward slashes, /, are the required path separator in the {filename} directive on all operating systems, including Windows.</p>
<p>For example, a Pelican project might be structured like this:</p>
<p>website/
├── content
│   ├── category/
│   │   └── article1.rst
│   ├── article2.md
│   └── pages
│       └── about.md
└── pelican.conf.py
In this example, article1.rst could look like this:</p>
<p>The first article</p>
<h6></h6>
<p>:date: 2012-12-01 10:02</p>
<p>See below intra-site link examples in reStructuredText format.</p>
<p><code>a link relative to the current file &lt;{filename}../article2.md&gt;</code><em>
<code>a link relative to the content root &lt;{filename}/article2.md&gt;</code></em>
and article2.md:</p>
<p>Title: The second article
Date: 2012-12-01 10:02</p>
<p>See below intra-site link examples in Markdown format.</p>
<p><a href="{filename}category/article1.rst">a link relative to the current file</a>
<a href="{filename}/category/article1.rst">a link relative to the content root</a>
Linking to static files
You can link to static content using {static}path/to/file. Files linked to with this syntax will automatically be copied to the output directory, even if the source directories containing them are not included in the STATIC_PATHS setting of the project’s pelicanconf.py file.</p>
<p>For example, a project’s content directory might be structured like this:</p>
<p>content
├── images
│   └── han.jpg
├── pdfs
│   └── menu.pdf
└── pages
    └── test.md
test.md would include:</p>
<p><img alt="Alt Text" src="/images/han.jpg">
<a href="/pdfs/menu.pdf">Our Menu</a>
Site generation would then copy han.jpg to output/images/han.jpg, menu.pdf to output/pdfs/menu.pdf, and write the appropriate links in test.md.</p>
<p>If you use {static} to link to an article or a page, this will be turned into a link to its source code.</p>
<p>Attaching static files
Starting with Pelican 3.5, static files can be “attached” to a page or article using this syntax for the link target: {attach}path/to/file This works like the {static} syntax, but also relocates the static file into the linking document’s output directory. If the static file originates from a subdirectory beneath the linking document’s source, that relationship will be preserved on output. Otherwise, it will become a sibling of the linking document.</p>
<p>This only works for linking to static files.</p>
<p>For example, a project’s content directory might be structured like this:</p>
<p>content
├── blog
│   ├── icons
│   │   └── icon.png
│   ├── photo.jpg
│   └── testpost.md
└── downloads
    └── archive.zip
pelicanconf.py would include:</p>
<p>PATH = 'content'
ARTICLE_PATHS = ['blog']
ARTICLE_SAVE_AS = '{date:%Y}/{slug}.html'
ARTICLE_URL = '{date:%Y}/{slug}.html'
testpost.md would include:</p>
<p>Title: Test Post
Category: test
Date: 2014-10-31</p>
<p><img alt="Icon" src="/icons/icon.png">
<img alt="Photo" src="/photo.jpg">
<a href="/downloads/archive.zip">Downloadable File</a>
Site generation would then produce an output directory structured like this:</p>
<p>output
└── 2014
    ├── archive.zip
    ├── icons
    │   └── icon.png
    ├── photo.jpg
    └── test-post.html
Notice that all the files linked using {attach} ended up in or beneath the article’s output directory.</p>
<p>If a static file is linked multiple times, the relocating feature of {attach} will only work in the first of those links to be processed. After the first link, Pelican will treat {attach} like {static}. This avoids breaking the already-processed links.</p>
<p>Be careful when linking to a file from multiple documents: Since the first link to a file finalizes its location and Pelican does not define the order in which documents are processed, using {attach} on a file linked by multiple documents can cause its location to change from one site build to the next. (Whether this happens in practice will depend on the operating system, file system, version of Pelican, and documents being added, modified, or removed from the project.) Any external sites linking to the file’s old location might then find their links broken. It is therefore advisable to use {attach} only if you use it in all links to a file, and only if the linking documents share a single directory. Under these conditions, the file’s output location will not change in future builds. In cases where these precautions are not possible, consider using {static} links instead of {attach}, and letting the file’s location be determined by the project’s STATIC_SAVE_AS and STATIC_URL settings. (Per-file save_as and url overrides can still be set in EXTRA_PATH_METADATA.)</p>
<p>Note</p>
<p>When using {attach}, any parent directory in <em>_URL / </em>_SAVE_AS settings should match each other. See also: URL settings</p>
<p>Linking to authors, categories, index and tags
You can link to authors, categories, index and tags using the {author}name, {category}foobar, {index} and {tag}tagname syntax.</p>
<p>Deprecated internal link syntax
To remain compatible with earlier versions, Pelican still supports vertical bars (||) in addition to curly braces ({}) for internal links. For example: |filename|an_article.rst, |tag|tagname, |category|foobar. The syntax was changed from || to {} to avoid collision with Markdown extensions or reST directives. Similarly, Pelican also still supports linking to static content with {filename}. The syntax was changed to {static} to allow linking to both generated articles and pages and their static sources.</p>
<p>Support for the old syntax may eventually be removed.</p>
<p>Including other files
Both Markdown and reStructuredText syntaxes provide mechanisms for this.</p>
<p>Following below are some examples for reStructuredText using the include directive:</p>
<p>.. include:: file.rst
Include a fragment of a file delimited by two identifiers, highlighted as C++ (slicing based on line numbers is also possible):</p>
<p>.. include:: main.cpp
    :code: c++
    :start-after: // begin
    :end-before: // end
Include a raw HTML file (or an inline SVG) and put it directly into the output without any processing:</p>
<p>.. raw:: html
    :file: table.html
For Markdown, one must rely on an extension. For example, using the mdx_include plugin:</p>
<div class="highlight"><pre><span></span><code>{! template.html !}
</code></pre></div>

<p>Importing an existing site
It is possible to import your site from WordPress, Tumblr, Dotclear, and RSS feeds using a simple script. See Importing an existing site.</p>
<p>Translations
It is possible to translate articles. To do so, you need to add a lang meta attribute to your articles/pages and set a DEFAULT_LANG setting (which is English [en] by default). With those settings in place, only articles with the default language will be listed, and each article will be accompanied by a list of available translations for that article.</p>
<p>Note</p>
<p>This core Pelican functionality does not create sub-sites (e.g. example.com/de) with translated templates for each language. For such advanced functionality the i18n_subsites plugin can be used.</p>
<p>By default, Pelican uses the article’s URL “slug” to determine if two or more articles are translations of one another. (This can be changed with the ARTICLE_TRANSLATION_ID setting.) The slug can be set manually in the file’s metadata; if not set explicitly, Pelican will auto-generate the slug from the title of the article.</p>
<p>Here is an example of two articles, one in English and the other in French.</p>
<p>The English article:</p>
<p>Foobar is not dead</p>
<h6></h6>
<p>:slug: foobar-is-not-dead
:lang: en</p>
<p>That's true, foobar is still alive!
And the French version:</p>
<p>Foobar n'est pas mort !</p>
<h6></h6>
<p>:slug: foobar-is-not-dead
:lang: fr</p>
<p>Oui oui, foobar est toujours vivant !
Post content quality notwithstanding, you can see that only item in common between the two articles is the slug, which is functioning here as an identifier. If you’d rather not explicitly define the slug this way, you must then instead ensure that the translated article titles are identical, since the slug will be auto-generated</p>
  </div><!-- /.entry-content -->
</section>
    </main>

    <footer>
      <section id="footer-title">
        <p class="title">© hexcowboy</p>
      </section>

      <section id="footer-links">
        <a href="https://twitter.com/hexcowboy" target="_blank">
          <p class="twitter-handle">@hexcowboy</p>
        </a>
      </section>
    </footer>

  </body>
</html>